Basic implementation of MIPS32 (word addressable), taking a subset of the larger instruction set (though having the functionality to extend). 
This implementation has 32 registers, each of 32 bits (R0 being directly connected to ground) 

It also has a special purpose 32 bit register-> Program Counter (PC). It points to the next instruction in memory to be fetched and executed. 


Instructions being considered: 

1. Load and Store Instructions 

LW Rd, #offset(Rs)  // Rd = mem[#offset+Rs] 
Sw Rd, -#offset(Rs) // mem[Rs-#offset] = Rd 


2. Arithmetic and Logic Instructions 

2.1 Only register instructions

ADD R1, R2, R3 // R1 = R2 + R3 
SUB R1, R2, R3 //R1 = R2 - R3 
AND R20, R1, R5 //R20 = R1 & R5 
OR R11, R3, R2 //R11 = R2 | R3 
MUL R1, R2, R3 //R1 = R2*R3 
SLT R1, R2, R3 //Set if less than -> if(R2<R3) -> R1 = 1 , else R1 = 0 

2.2 Immediate instructions 

ADDI R1, R2, #offset // R1 = R2 + #offset 
SUBI R1, R2, #offset // R1 = R2 - #offset 
SLTI R1, R2, #offset // if(R2 < #offset) -> R1 = 1 , else R1 = 0 

3. Branch Instructions 

BEQZ R1, Label //Branch to Label if R1 = 0 
BNEQZ R1, Label //Branch to Label if R1 = 1 

4. Miscellaneous Instruction 

HLT 

5. Jump Instruction (Present in MIPS 32, not implemented here) 
J Label (Unconditional jump to label) 


Addressing Modes: 
(Memory is word (32 bits) addressable
1. Register addressing 
	ADD R1, R2, R3  //R1 = R2 + R3
2. Immediate addressing 
	ADDI R1, R2, 200 //R1 = R2 + 200
3. Base addressing 
	LW R5, #offset(R1) // R5 = Mem[R1+#offset] 
4. PC Relative addressing 
	BEQZ R3, Label (16 bit offset is added to PC to get the target address) 
5. Pseudo-direct addressing 
	J Label (16 bit offset is added to PC to get the target address) 

MIPS32 Instruction Cycle 
We divide the instruction execution cycle into five steps: 
1. IF -> Instruction Fetch 
2. ID -> Instruction Decode/ Register Fetch 
3. EX -> Execution/ Effective Address Calculation 
4. MEM-> Memory Access/ Branch Completion 
5. WE -> Register Write-back 




Some instructions require two register operands 'rs' and 'rt' as input, 
while some require only 'rs'. This is only known after the instruction is decoded. 
While decoding is going on, we can prefetch the registers in parallel (May or may not be required later). 
In short, assume by default that the instruction is "R-type" 





